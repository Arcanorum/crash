{"name":"Crash","tagline":"Bundles RBush and SAT.js for easy 2D collisions.","body":"Crash\r\n=====\r\nv.1.1.0\r\n\r\nCrash performs optimized 2D collisions, powered by [RBush] and [SAT.js], written in javascript.  \r\nIt's most obvious use-case is in game engines, but it's flexible enough to be used anywhere.  \r\nCrash is perfectly happy in the browser and on Node.js.\r\n\r\n\r\n## Contents\r\n* [Contents](#contents)\r\n* [Installation](#installation)\r\n  * [Node.js](#nodejs)\r\n  * [Browser](#browser)\r\n  * [Require.js](#requirejs)\r\n* [Getting Started](#getting-started)\r\n  * [Adding Colliders](#adding-colliders)\r\n  * [Testing for collisions](#testing-for-collisions)\r\n  * [Unleashing the power of Crash](#unleashing-the-power-of-crash)\r\n  * [What kind of sorcery is this !?](#what-kind-of-sorcery-is-this-)\r\n  * [But what's up with that `moved()`?](#but-whats-up-with-that-moved)\r\n* [Contributing](#contributing)\r\n* [Overview](#overview)\r\n* [API](#api)\r\n  * [Crash]\r\n  * [AABB updates][Crash.updateAABB()]\r\n  * [Collision testing][Crash.test()]\r\n  * [Colliders][Crash.Collider]\r\n  * [Other][Listener]\r\n* [License](#License)\r\n\r\n\r\n## Installation\r\nAt the moment, package managers are not yet set up. Just download one of the following files from this repo and load it in your project.\r\n\r\n1. [crash.js]: full source, with comments and all (13.6kB).\r\n2. [crash.min.js]: minified, ready to be used in production (5.6kB or 1.8kB gzipped).\r\n\r\nWhen you have installed Crash, head over to the [Getting Started section][getting-started].\r\n\r\n### Node.js\r\nAdd the following snippet to your code:\r\n```javascript\r\nvar Crash = require(\"path/to/crash.js\");\r\n```\r\nNow, you can use the [API] on the `Crash` variable.\r\n\r\n### Browser\r\nAdd the following snippet to your HTML file:\r\n```html\r\n<script type=\"text/javascript\" src=\"path/to/crash.js\"></script>\r\n```\r\nNow, you can use the [API] on the global `Crash` variable (`window.Crash`).\r\n\r\n### Require.js\r\nIf you're using [require.js] in your project, use the following snippet to load Crash:\r\n```javascript\r\ndefine([\"path/to/crash\"], function(Crash) {\r\n    // Your code...\r\n});\r\n```\r\nNow, you can use the [API] on the `Crash` variable in your module.\r\n\r\n\r\n\r\n\r\n## Getting Started\r\nBefore you can do anything useful with Crash, you have to initialize it. You can do this easily by calling:\r\n```javascript\r\nCrash.init();\r\n```\r\nThis method will make sure that RBush is being initialized correctly, so Colliders can be added.  \r\n`Crash.init()` accepts one argument, a number called `maxEntries`. This is specific to RBush, so I refer to their [documentation][rbush-docs]. This argument is not required, though, so just leave it out for now and use the default value.  \r\n\r\n> __Fun Fact:__ Actually, when `Crash.init()` has not been called yet, a lot of things just work, and nothing should break. You can use the full API safely, although some things may not work correctly (specifically those that need rbush). Although it should be safe, it's a good habit to call `Crash.init()` before you do anything.\r\n\r\n\r\n### Adding Colliders\r\nNow that everything is ready to roll, let's add some colliders. All colliders in Crash inherit from the `Crash.Collider` class, which provides some basic methods that perform household tasks, like moving, updating its AABB and testing collisions. That would lead us too far, though, so I refer to the full [API docs][API] for more info.  \r\nAll that stuff is awesome, but a `Collider` on its own is not very useful: it doesn't have a shape. Before you can use a Collider, you have to give it a shape, but, luckily, Crash has some built-in ones for us. Let's try them out!\r\n\r\n```javascript\r\nvar point =   new Crash.Point  (new Crash.Vector(0,0));\r\nvar circle =  new Crash.Circle (new Crash.Vector(5,2),  10);\r\nvar box =     new Crash.Box    (new Crash.Vector(-40,0), 10, 15);\r\nvar polygon = new Crash.Polygon(new Crash.Vector(3,7),  [new Crash.Vector(0,0), new Crash.Vector(5,0), new Crash.Vector(2,3)]);\r\n```\r\n\r\nWow, what's all that!? Let's clarify this step by step.\r\n\r\n1. Each shape has its own constructor, so a point is initialized with `Crash.Point` etc.\r\n2. The first argument to each constructor is a Vector, setting the base position for the Collider. So, for a Point, this would be its position, for a Circle it would be the center and for a Box it would be the bottom-left corner.\r\n3. Some constructors take a few extra arguments: \r\n * Circle: the radius\r\n * Box: the width and height\r\n * Polygon: an array of Vectors, relative to the base position\r\n4. All the above arguments are required.\r\n5. These constructors also take two more (optional) arguments:\r\n * insert: a boolean indicating whether the collider should be inserted into RBush. More info on this is following in the next few steps.\r\n * data: some data to add to the collider. This can be anything you want and doesn't do anything for Crash; it's just there for your convenience.\r\n\r\n> __Fun Fact:__ the unit you use for the numbers is completely up to you. Crash only stores the numbers, you can interpret them as you wish, so you can use pixels, millimeters or even some game-specific unit you invented!\r\n \r\n> __Important Fun Fact:__ there is a very important difference between Point and Vector: a Point is a Collider, so it can be used for collision checks. A Vector, on the other hand, is just a thing that defines positions in Colliders, like the center of a Circle or the corners of a Polygon.\r\n\r\n\r\n### Testing for collisions\r\nNow that we have some colliders, we would probably like to know if they are colliding. To do this, we use the `Crash.test()` method:\r\n\r\n```javascript\r\nif(Crash.test(circle, box)) {\r\n    alert(\"Oh my, there is a collision!\");\r\n}\r\n```\r\n\r\nThis is already quite nice, but not very useful: now we know that our colliders are touching, but we don't know how to undo this crash (pun intended)! Enter `Response`, the all-knowing crash guru.  \r\nFirst, let's create one:\r\n\r\n```javascript\r\nvar res = new Crash.Response();\r\n```\r\n\r\nThe Response class is copied from SAT, so for further information about the kind of info it provides, I refer to the [SAT.js docs][sat-docs].\r\n\r\nThen, let's do a subtle change to our testing code:\r\n\r\n```javascript\r\nif(Crash.test(circle, box, res)) {\r\n    alert(\"Oh my, there is a collision!\");\r\n}\r\n```\r\n\r\nNow, we can query the Response for some useful information and undo this embarassing crash:\r\n\r\n```javascript\r\nif(Crash.test(circle, box, res)) {\r\n    alert(\"Oh my, there is a collision!\");\r\n    var overlap = res.overlapV;\r\n    circle.moveBy(-overlap.x, -overlap.y);\r\n}\r\n```\r\n\r\nAnd just like that, our colliders aren't touching anymore!\r\n\r\n> __Fun Fact:__ you could also use circle.test(box, res). This just abstracts `Crash.test()`, but it's a little more concise.\r\n\r\n\r\n\r\n### Unleashing the power of Crash\r\n\r\nWasn't that exciting!? Just wait for what's to come!  \r\nI assume you don't want to plow through heaps of loops and complex code to do everything we did in the previous steps for *every* frame and *every* collider.  \r\nThat's where Crash's real power comes in. Let's `insert()` our colliders and get to some serious collision checking!\r\n\r\n```javascript\r\nCrash.insert(point);\r\nCrash.insert(circle);\r\nCrash.insert(box);\r\nCrash.insert(polygon);\r\n```\r\n\r\nYou could have achieved the same by passing `true` for the `insert` argument of the constructors, like I mentioned at the beginning.\r\n\r\n> __Fun Fact:__ just like `Crash.test()`, you could use `collider.insert()`, as a convenience method.\r\n\r\nNow that our colliders have been inserted, we can let Crash do all the hard work: it will do all the collision checks for us! And because Crash leverages the power of RBush, only the checks that make sense will actually be performed, causing a huge gain in CPU time.\r\n\r\nBefore we can let Crash do anything, we would like to make sure it can report to us what it's doing, to let us react to collisions. To do that, we add a listener with `Crash.onCollision()`. This listener will be called every time a collision occurs.\r\n\r\n```javascript\r\nvar listener = function(a, b, res, cancel) {\r\n    alert(\"Oh my, there is a collision!\");\r\n}\r\nCrash.onCollision(listener);\r\n```\r\n\r\nHere, `a` and `b` are the colliders that are colliding, `res` is the all-knowing Response, and cancel is a function that cancels all further collision checks for this collider. This may be useful if you move the collider (and all checks become invalid) and/or when you use `Crash.check()`, which we will cover in the next step.\r\n\r\n> __Fun Fact:__ you can easily remove a listener with `Crash.offCollision(listener)`. Just make sure you saved it somewhere when you added it, so you can pass it to `offCollision()` as an argument!\r\n\r\nAnd now, we're ready for some serious stuff:\r\n\r\n```javascript\r\nCrash.testAll(circle);\r\n```\r\n\r\nThis runs collision checks for all inserted colliders that may be colliding with our circle.\r\nAs our circle is colliding with all the other colliders, except our box, the listener we added previously will be called once for `point` and once for `polygon`, but not for `box`. For every call, `a` equals `circle`, `b` the respective collider and `res` gives us some info about the collision.\r\n\r\n> __Fun Fact:__ Note that, like with `Crash.test()`, we can pass in a Response, but we don't have to. If we don't, Crash will make one for us and pass that around to the listeners. How convenient!\r\n\r\n\r\n\r\n### What kind of sorcery is this !?\r\nWe can even go one step further: let's make Crash do __everything__!\r\n\r\nFor this to work, we need to make sure that we call `Crash.moved()` on all the colliders that have moved:\r\n\r\n> __Fun Fact:__ you probably already guessed: you can use `collider.moved()` instead!\r\n\r\n```\r\nCrash.moved(point);\r\nCrash.moved(circle);\r\n```\r\n\r\nThis way, Crash will know it only has to call `testAll` for these colliders, the ones that have moved.\r\n\r\nAnd, now, ladies and gentleman, the holy grail of collision checking:\r\n\r\n```javascript\r\nCrash.check();\r\n```\r\n\r\nAnd it's done. All checks have run, our colliders are where they should be. With just one function call. Such wow.\r\n\r\n\r\n#### But what's up with that `moved()`?\r\nAll the built-in methods (like `moveTo`, `setOffset` and `rotate`) already call this for you, so you don't have to worry about this. You should only worry when you insert a collider for the first time. Normally, when designing your game (or anything else), you would make sure your colliders aren't already colliding when you load them. When this is the case, though, you can call `Crash.checkAll()` just after you loaded your colliders. This will do the same as `check()`, but for all colliders, not just the ones that moved. Neat, isn't it?\r\n\r\n\r\n\r\n## Contributing\r\n\r\nAll contributions are very welcome!  \r\nTypos, bug fixes, code cleanup, documentation, tests, a website, you name it!\r\n\r\nQuestions and feature requests belong in the [issue tracker], __with the right tags__.\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n## Overview\r\n### Or: about the check() loop\r\n\r\n> In this section, I'll explain the basics of Crash, how it works, how the methods fit together and what the basic workflow is.\r\n\r\nIn this section, I'll assume you're using Crash to power a game (engine), because that's probably what the majority will be using it for, and not having to cover all the edge cases makes it easier to explain.\r\n\r\nThe very heart of Crash is its [Crash.check()] loop: this is where all the magic is happening. During the update cycle of your game (engine), you can move your objects around freely (probably using some physics) and not care about collisions; just move them to where you would like them to be. You can move the Colliders either by using the move functions (`moveBy`, `rotate`,...), which is easiest way, or by setting their `x` and `y` coordinates. If you're using the latter, you have to be cautious.  \r\nAfter every move, a few things have to happen:\r\n\r\n1. The AABB of the Collider must be updated. Use [Crash.updateAABB()] to achieve this.\r\n2. The Collider's position in RBush must be updated. Use [Crash.update()] for this, but be aware that this calls [Crash.updateAABB()] also! You could also manually `remove()` and re-`insert()` the collider in `rbush`, just like `update()` is doing.\r\n3. The Collider must be added to [Crash.__moved] in order for it to be collision checked during the next [Crash.check()]. Use [Crash.addToMoved()] to achieve this. You could also add it manually, but make sure you're no adding it twice.\r\n\r\n1\\. and 2. can be bundled in one [Crash.update()] call, and all the above can be bundled in one [Crash.moved()] call, which is the method the move functions are calling for you. This is why using the move functions is the easiest: all this is done for you.\r\n\r\nWhen all your Colliders are in place, just call [Crash.check()]. This will iterate over [Crash.__moved] and do the following for every Collider (this happens in [Crash.testAll()]). Let's call this loop A.\r\n\r\nFirst, all the possible collisions are retrieved using RBush, with a [Crash.search()]. Then, for every possibly colliding collider (loop B), Crash will test for a collision using SAT, and if there is, it will call [Crash.\\_\\_onCollision()], which in turn calls the [Listener]s, passing in the two Colliders and the Response of the collision. If, during this [Crash.\\_\\_onCollision()], [Crash.BREAK] is set to true, loop B is stopped. This can happen when, for example, the first collider (that will be the one passed from A to B) is moved inside a [Listener]; the Collider will then be added to [Crash.\\_\\_moved] and thus be checked in the next iteration of loop A, making everything that happens in B useless (it will be done again in the next iteration of A, and the possible collisions may not be accurate anymore). This doesn't happen when the second Collider passed to [Listener]s (the one 'generated' by B) is moved, because it will just be added to [Crash.\\_\\_moved] to be handled in the next iteration of A, but doesn't render everything happening inside B useless (it's the first Collider that is our focus).  \r\nAt the end of loop B (so, for every iteration of A), the Collider passed from A to B has its `lastPos` set to a copy of its position at that moment.  \r\nThen, [Crash.testAll()] \\(loop B\\) returns, and the next iteration of A begins.\r\n\r\nAt the end of [Crash.check()] \\(loop A\\), all the Colliders that have been processed have their `lastCheckedPos` set to a copy of their position at that time.\r\n\r\n\r\nI hope this has helped to clarify some of Crash's misty bits. If it hasn't, let me know and take a look at the source: it's not that complex and it's not that much.\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n## API\r\n\r\n\r\n\r\n### Crash\r\nThis is the main object, returned by `require()`, injected by `defined()` or set as `window.Crash`. Anything related to Crash sits in this namespace.\r\n\r\n### Crash.RBush : *function*\r\nThe RBush constructor, as returned by the rbush module.\r\n\r\n### Crash.SAT : *object*\r\nThe SAT object, as returned by the SAT.js module.\r\n\r\n### Crash.Vector : *constructor*\r\n*Alias:* [Crash.V]  \r\nRepresents a vector, used by the Colliders to define their positions and corners, and by SAT to perform its calculations.  \r\nI refer to the [SAT docs][sat-docs] for the API definition.\r\n\r\n### Crash.V : *constructor*\r\n*Alias:* [Crash.Vector]  \r\nAlias for [Crash.Vector].\r\n\r\n### Crash.Response : *constructor*\r\nProvides information about a collision, like overlap distance and direction.  \r\nI refer to the [SAT docs][sat-docs] for the API definition.\r\n\r\n### Crash.rbush : *RBush*\r\nThe RBush instance that holds the colliders. This is (mostly) used internally to optimize collision checks.  \r\nFor further documentation, please see the [RBush docs][rbush-docs].\r\n\r\n### Crash.RESPONSE : *Response*\r\nUsed by the testing functions. When no Response has been passed to them, they use this instead.\r\n\r\n### Crash.BREAK : *boolean*\r\nWhether to stop the currently running check loop. This is set to `true` by [Crash.cancel()]. See [Crash.testAll()] for more info.\r\n\r\n### Crash.MAX_CHECKS : *number*\r\nThe maximum amount of times to run [Crash.testAll()] during [Crash.check()]. See [Crash.check()] for more info.\r\n\r\n### Crash.OVERLAP_LIMIT : *number*\r\nThe minimum amount two [Crash.Collider]s should overlap to call the [Listener]s. If falsy, `OVERLAP_LIMIT` will not be taken into account. See [Crash.testAll()] for more info.\r\n\r\n### Crash.__listeners : *Array.\\<function\\>*\r\n*Private*  \r\nAn array of functions to call when a collision occurs. You can add to this with [Crash.onCollision()].\r\n\r\n### Crash.__notYetInserted : *Array.\\<Collider\\>*\r\n*Private*  \r\nWhen [Crash.init()] has not yet been called, and thus when [Crash.rbush] isn't defined yet, Colliders that are [Crash.insert()]ed are pushed to this array, to be inserted into [Crash.rbush] when [Crash.init()] is called.\r\n\r\n### Crash.__moved : *Array.\\<Collider\\>*\r\n*Private*  \r\nAn array of colliders that have moved since the last [Crash.check()]. This is used internally by [Crash.check()] to optimize collision checks. For more info, see [Crash.check()].\r\n\r\n\r\n\r\n\r\n\r\n\r\n### Crash.init ([number maxEntries:9]) - .\r\n__maxEntries:__ *number|optional. Default: 9*. The maximum amount of [Crash.Collider]s in a Node. See the [RBush docs][rbush-docs] for more info.  \r\n__*return:*__ *Crash*. For chaining.\r\n\r\nInitializes Crash, and more specifically RBush. It creates [Crash.rbush], with `maxEntries` and aabb coordinate names `.aabb.x1`, `.aabb.y1`, etc. Then, it inserts all the [Crash.Collider]s from [Crash.__notYetInserted] in [Crash.rbush].  \r\nYou should be able to use all the APIs safely without calling [Crash.init()], but some may not work correctly (specifically those that need RBush). It is a good habit, though, to call [Crash.init()] before you do anything else.\r\n\r\n```javascript\r\nCrash.init(16);\r\n\r\nCrash.insert(...);\r\nCrash.search(...);\r\n```\r\n\r\n\r\n### Crash.insert (Collider collider) - .\r\n__collider:__ *Collider*. The [Crash.Collider] to insert.  \r\n__*return:*__ *Crash*. For chaining.\r\n\r\nInserts [Crash.Collider]s in [Crash.rbush], or in [Crash.__notYetInserted] if the former is not defined.  \r\nBefore [Crash.Collider]s turn up in [Crash.search()]s or in collision checks (performed by [Crash.testAll()]), you must [Crash.insert()] them.  \r\nYou can use [Crash.remove()] to get them out.\r\n\r\n```javascript\r\nvar circle = new Crash.Circle(new Crash.V(0,0), 5);\r\n// circle won't turn up in searches and collision checks\r\nCrash.insert(circle);\r\n// Now it will!\r\n```\r\n\r\n\r\n### Crash.remove (Collider collider) - .\r\n__collider:__ *Collider*. The [Crash.Collider] to remove.  \r\n__*return:*__ *Crash*. For chaining.\r\n\r\nRemoves [Crash.Collider]s from [Crash.rbush], or from [Crash.__notYetInserted] if the former is not defined.\r\n\r\n```javascript\r\nCrash.insert(collider);\r\n// collider will turn up in searches and collision checks\r\nCrash.remove(collider);\r\n// now, it won't, anymore\r\n```\r\n\r\n\r\n### Crash.all () - *Collider[]*\r\n__*return:*__ *Array.\\<Collider\\>*. An array containing all the [Crash.Collider]s that have been [Crash.insert()]ed.\r\n\r\nReturns all the [Crash.Collider]s that have been [Crash.insert()]ed.\r\n\r\n```javascript\r\nvar allColliders = Crash.all();\r\n```\r\n\r\n\r\n### Crash.search (Collider collider) - *Collider[]*\r\n__collider:__ *Collider*. The [Crash.Collider] to base the search on.  \r\n__*return:*__ *Array.\\<Collider\\>*. An array of colliders that may be colliding with `collider`.\r\n\r\nRuns `rbush.search()` based on a [Crash.Collider], which will look for all [Crash.Collider]s that have (nearly) colliding axis-aligned bounding boxes (AABBs). This search is optimized by an RTree (that's a special algorithm, designed for this), implemented by RBush.\r\n\r\nRBush usually requires an array of AABB coordinates to perform a search, so [Crash.search()] translates the [Crash.collider]'s `aabb` coordinates to the correct array.\r\n\r\n```javascript\r\nvar possibleCollisions = Crash.search(collider);\r\n// returns an array containing closeByCollider, but not veryFarAwayCollider\r\n```\r\n\r\n\r\n### Crash.clear() - .\r\n__*return:*__ *Crash*. For chaining.\r\n\r\nClears Crash from all [Crash.Collider]s. This calls `rbush.clear()`, and clears [Crash.__notYetInserted] and [Crash.__moved].\r\n\r\n\r\n### Crash.addToMoved (Collider collider) - .\r\n__collider:__ *Collider*. The [Crash.Collider] that should be added to [Crash.__moved].  \r\n__*return:*__ *Crash*. For chaining.\r\n\r\nAdds a [Crash.Collider] to [Crash.__moved], so it gets collision checked during the next [Crash.check()] round. This does not update the Collider's AABB! If you want to do both, use [Crash.moved()] instead.  \r\nNote that the built-in move methods of Colliders (`moveBy`, `rotate`,...) already call [Crash.moved()] \\(which calls `addToMoved()`\\) for you.\r\n\r\n```javascript\r\ncollider.pos.x += 5;\r\n// Is not taken into account in the next check() round\r\n\r\nCrash.moved(collider);\r\n// Now it will\r\n```\r\n\r\n```javascript\r\ncollider.moveBy(5,0);\r\n// Crash.moved(collider), and thus Crash.addToMoved(collider), has already been called for you\r\n```\r\n\r\n\r\n### Crash.update (Collider collider) - .\r\n__collider:__ *Collider*. The [Crash.Collider] that should be updated.  \r\n__*return:*__ *Crash*. For chaining.\r\n\r\nUpdates the `aabb` of the [Crash.Collider] \\(using [Crash.updateAABB()]\\) and updates its position in RBush.\r\n\r\n\r\n### Crash.moved (Collider collider) - .\r\n__collider:__ *Collider*. The [Crash.Collider] that has moved.  \r\n__*return:*__ *Crash*. For chaining.\r\n\r\nNotifies Crash that a [Crash.Collider] has moved. This calls [Crash.update()] and [Crash.addToMoved()], so all the housekeeping is done in one function call.\r\nNote that this is already taken care of for you when using the built-in move methods of the Colliders (`moveBy`, `rotate`,...).\r\n\r\n```javascript\r\ncollider.pos.x += 5;\r\n// Is not taken into account in the next check() round\r\n// and the aabb is not updated\r\n\r\nCrash.moved(collider);\r\n// Now it will\r\n// and its aabb is updated\r\n```\r\n\r\n```javascript\r\ncollider.moveBy(5,0);\r\n// Crash.move(collider) has already been called for you\r\n```\r\n\r\n\r\n### Crash.reset ([number maxEntries]) - .\r\n__maxEntries:__ *number|optional*. See [Crash.init()].  \r\n__*return:*__ *Crash*. For chaining.\r\n\r\nResets Crash to a default, empty state. This basically calls [Crash.clear()] and [Crash.init()], and resets some variables.  \r\nThis method is primarily used by the test suite.\r\n\r\n\r\n### Crash.cancel () - *false*\r\n__*return:*__ *false*. Makes it easy to stop event propagation in some EventEmitters.\r\n\r\nThis method cancels the current check loop. When you call [Crash.check()], a loop will start, which calls [Crash.testAll()] for every collider that has moved since the last [Crash.check()]. Then, [Crash.testAll()] will do a [Crash.search()] and perform all the necessary checks, calling [Crash.__onCollision()] for every collision. Now, if you move a collider during the [Crash.testAll()] loop (i.e. in a [Listener]), it will be added to [Crash.__moved] and all the following collision checks become unnecessary, because they will run again in the next iteration of the [Crash.check()] loop.  \r\nThat's where [Crash.cancel()] comes in. When you move a collider inside a [Listener], call [Crash.cancel()] (or the fourth argument of the listener, which is the exact same function) to cancel all further (unnecessary) collision checks.\r\n\r\n```javascript\r\nCrash.onCollision(function(a, b, res, cancel) {\r\n    a.moveBy(-res.overlapV.x, -res.overlapV.y);\r\n    cancel();\r\n});\r\n```\r\n\r\n> __Important Note:__ all the above is only valid for the *first* collider (named `a`), because that's the one that collision checks are run for. If yo move `b`, nothing has to be done.\r\n\r\n```javascript\r\nCrash.onCollision(function(a, b, res, cancel) {\r\n    b.moveBy(res.overlapV.x, res.overlapV.y);\r\n});\r\n```\r\n\r\n\r\n### Crash.getTestString (string type1, string type2) - *string*\r\n__type1:__ *string*. The type of the first [Crash.Collider].  \r\n__type2:__ *string*. The type of the second [Crash.Collider].  \r\n__*return:*__ *string*. The appropriate SAT testing string.\r\n\r\nGives you the right SAT method name to test for a collision between two [Crash.Collider]s. Be sure to pass [Collider.type], ans not a [Crash.Collider]!\r\n\r\n```javascript\r\nvar circle = new Crash.Circle(new Crash.Vector(0,0), 10);\r\nvar box = new Crash.Box(new Crash.Vector(5,5), 7, 15);\r\n\r\nvar string = Crash.getTestString(circle.type, box.type); // 'testCirclePolygon'\r\n```\r\n\r\n\r\n### Crash.onCollision (function listener) - .\r\n__listener:__ *function*. The [Listener] to add to the `collision` event. See [Listener] for more info.  \r\n__*return:*__ *Crash*. For chaining.\r\n\r\nAdds a [Listener] to [Crash.__listeners] and will be called every time a collision occurs. See [Listener] for more info.\r\n\r\n```javascript\r\nvar listener = function(a, b, res, cancel) {\r\n    alert(\"Oh my, there is a collision!\");\r\n    a.moveBy(-res.overlapV.x, -res.overlapV.y);\r\n}\r\nCrash.onCollision(listener);\r\n```\r\n\r\n\r\n### Crash.offCollision (function listener) - .\r\n__listener:__ *function*. The [Listener] to remove.\r\n__*return:*__ *Crash*. For chaining.\r\n\r\nRemoves a [Listener] from the `collision` event. So, this is the opposite of [Crash.onCollision()].\r\n\r\n```javascript\r\nCrash.offCollision(listener);\r\n```\r\n\r\n\r\n### Crash.__onCollision (Collider a, Collider b, Response res) - .\r\n*Private*  \r\n__a:__ *Collider*. The [Crash.Collider] that collides with `b`.  \r\n__b:__ *Collider*. The [Crash.Collider] that collides with `a`.  \r\n__res:__ *Response*. The [Crash.Response] for thsi collision.  \r\n__*return:*__ *Crash*. For chaining.\r\n\r\nCalls all the [Listener]s when a `collision` event occurs. It takes three arguments: the two [Crash.Collider]s that are colliding and the [Crash.Response] for this collision. It will take care of injecting [Crash.cancel()] by itself.  \r\nIntended for private use.\r\n\r\n\r\n### Crash.extend (function child, function base) - *undefined*\r\n__child:__ *function*. This constructor that inherits from `parent`.  \r\n__base:__ *function*. The constructor that is the parent of `child`.  \r\n__*return:*__ *undefined*.\r\n\r\nExtends the prototype chain of `base` to `child`, so child inherits from base. This is used to make the collider classes inherit from `Collider`.\r\n\r\n```javascript\r\nvar Child = function(){}\r\nvar Parent = function(){}\r\nCrash.extend(Child, Parent);\r\n```\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n### Crash.updateAABB (Collider collider) - .\r\n__collider:__ *Collider*. The [Crash.Collider] whose AABB should be updated.  \r\n__*return:*__ *Crash*. For chaining.\r\n\r\nCalls [Crash.updateAABBPolygon()], [Crash.updateAABBBox()], [Crash.updateAABBCircle()] or [Crash.updateAABBPoint()] based on `collider`'s `type`.\r\n\r\n\r\n### Crash.updateAABBPolygon (Polygon collider) - .\r\n__collider:__ *Polygon*. The [Crash.Polygon] whose AABB should be updated.  \r\n__*return:*__ *Crash*. For chaining.\r\n\r\nUpdates a [Crash.Polygon]'s `aabb` attribute ([Collider.aabb]), based on its position and size.\r\n\r\n\r\n### Crash.updateAABBBox (Box collider) - .\r\n__collider:__ *Box*. The [Crash.Box] whose AABB should be updated.  \r\n__*return:*__ *Crash*. For chaining.\r\n\r\nUpdates a [Crash.Box]'s `aabb` attribute ([Collider.aabb]), based on its position and size.\r\n\r\n\r\n### Crash.updateAABBCircle (Circle collider) - .\r\n__collider:__ *Circle*. The [Crash.Circle] whose AABB should be updated.  \r\n__*return:*__ *Crash*. For chaining.\r\n\r\nUpdates a [Crash.Circle]'s `aabb` attribute ([Collider.aabb]), based on its position and size.\r\n\r\n\r\n### Crash.updateAABBPoint (Point collider) - .\r\n__collider:__ *Point*. The [Crash.Point] whose AABB should be updated.  \r\n__*return:*__ *Crash*. For chaining.\r\n\r\nUpdates a [Crash.Point]'s `aabb` attribute ([Collider.aabb]), based on its position.\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n### Crash.test (Collider a, Collider b, [Response res]) - *boolean*\r\n__a:__ *Collider*. The first [Crash.Collider] to test for.  \r\n__b:__ *Collider*. The second [Crash.Collider] to test for.  \r\n__res:__ *Response|optional*. The optional [Crash.Response] to use.  \r\n__*return:*__ *boolean*. Indicates whether there is a collision between `a`and `b`.\r\n\r\nTests for a collision between `a` and `b`, using SAT. The boolean return value indicates whether `a` and `b` are colliding: `true` if there is a collision, `false` otherwise.  \r\nYou can optionally pass in a [Crash.Response] to get some information about the collision (if there is one). If you don't, [Crash.RESPONSE] will be used instead.\r\n\r\n```javascript\r\nvar c1 = new Crash.Circle(new Crash.V(0,0), 5);\r\nvar c2 = new Crash.Point(new Crash.V(3,0));\r\nvar c3 = new Crash.Box(new Crash.V(15,20), 10, 10);\r\nvar res = new Crash.Response();\r\n\r\nCrash.test(c1, c2, res);\r\n// true, info in 'res'\r\n\r\nCrash.test(c1, c3);\r\n//false, info in Crash.RESPONSE\r\n```\r\n\r\n\r\n### Crash.testAll (Collider collider, [Response res]) - *boolean*\r\n__collider:__ *Collider*. The [Crash.Collider] to test collisions for.  \r\n__res:__ *Response|optional*. The optional [Crash.Response] to use.  \r\n__*return:*__ *boolean*. Whether the loop was stopped.\r\n\r\nTests for collisions between `collider` and any [Crash.Collider] that has been [Crash.insert()]ed in [Crash.rbush]. This will [Crash.search()] for `collider`, do a collision check for every [Crash.Collider] returned by that search and finally call [Crash.__onCollision()] for every collision.  \r\nYou can stop this loop (the one that checks for collisions) simply by calling [Crash.cancel()]. This sets [Crash.BREAK] to `true` (which is what `testAll` actually looks for). In [Listener]s, the recommended way is to call their `cancel` argument, which is the exact same function as [Crash.cancel()].  \r\nStopping the loop comes in handy when you move `collider` in any of the [Listener]s, because all consequent collision checks become unnecessary: you will have to run `testAll()` again for the new position.  \r\nThe value returned by `testAll()` indicates whether the loop was cancelled: if it was, `false` is returned, otherwise, it returns `true`.\r\n\r\nYou probably don't want to use this method, because it isn't really intended to be used publicly (but rather by [Crash.check()] internally), and [Crash.check()] is more convenient in most situations anyway. \r\n\r\nFinally, I would like to note a few things:\r\n\r\n1. `res` is optional: if you don't pass it, [Crash.RESPONSE] will be used instead.\r\n2. this method doesn't really provide direct feedback, like [Crash.test()] does: it rather calls the attached [Listener]s. This means `res` (or [Crash.RESPONSE]) will be passed to the [Listener]s, and will only hold info about the last collision when the call is finished.\r\n3. if this method returns `false`, the loop was cancelled, so you probably want to run it again.\r\n4. `testAll` will not run [Crash.\\_\\_onCollision()] when the overlap is smaller than [Crash.OVERLAP\\_LIMIT]. If [Crash.OVERLAP\\_LIMIT] is falsy, [Crash.\\_\\_onCollision] will always be called.\r\n5. `testAll` won't call [Crash.update()] on `collider`, so make sure it's updated.\r\n6. `testAll` is not really intended to be used publicly, but rather by [Crash.check()] internally.\r\n\r\n\r\n\r\n```javascript\r\nvar c1 = new Crash.Circle(new Crash.V(0,0), 5, true);\r\nvar c2 = new Crash.Point(new Crash.V(3,0), true);\r\nvar c3 = new Crash.Box(new Crash.V(15,20), 10, 10, true);\r\nvar res = new Crash.Response();\r\nCrash.onCollision(function(a, b, res, cancel){\r\n    alert(\"Oh my, there is a collision!\");\r\n});\r\n\r\nCrash.testAll(c1, res);\r\n// calls the listener for (c1, c2), but not for (c1, c3).\r\n// the response passed to the listener is 'res'.\r\n\r\nCrash.test(c2);\r\n// calls the listener for (c2, c1), but not for (c2, c3).\r\n// the response passed to the listener is Crash.RESPONSE.\r\n\r\nCrash.test(c3);\r\n// the listener will not be called.\r\n```\r\n\r\n\r\n### Crash.check () - .\r\n__*return:*__ *Crash*. For chaining.\r\n\r\nCalls [Crash.testAll()] for every [Crash.Collider] in [Crash.__moved]. This means that it performs collision checks for all the [Crash.Collider]s that have moved since the last [Crash.check()], which makes it the perfect function to handle collisions after everything was moved to new positions by physics. This integrates neatly in game loops: just do your updates, and then call [Crash.check()] to handle collisions.\r\n\r\nImportant to note is that Colliders may be moved inside [Listener]s: they will be added to [Crash.__moved] and checked in further iterations of the (current) [Crash.check()] loop.  \r\nTo prevent infinite loops (a collider is moved, checked in the following iteration, moved again, etc.), the loop will be forced to stop after [Crash.MAX_CHECKS] loops, which is `100` by default.\r\n\r\nFor a [Crash.Collider] to be checked, Crash must be notified it has moved (i.e. it must be pushed to [Crash.__moved]. You can use [Crash.moved()] or [Crash.addToMoved()] to achieve this.\r\n\r\n```javascript\r\n// apply updates to colliders ...\r\n// things may be colliding!\r\nCrash.check();\r\n// nothing is colliding anymore!\r\n// if the right listeners have been added, that is.\r\n```\r\n\r\n\r\n### Crash.checkAll () - .\r\n__*return:*__ *Crash*. For chaining.\r\n\r\nThis does the same as [Crash.check()], with one difference: it doesn't check [Crash.Collider]s in [Crash.__moved], but rather all [Crash.Collider]s (as returned by [Crash.all()]). This is especially handy when you just loaded you [Crash.Collider]s and you don't know which ones are colliding and/or have moved.\r\n\r\n```javascript\r\n// I have no idea what's up with my Colliders:\r\n// I haven't moved any yet, but I don't know if any are colliding!\r\nCrash.checkAll();\r\n// Ahh, that's better! Everything is sorted out!\r\n```\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n### Crash.Collider (string type, SAT.Polygon|SAT.Circle satCollider, [boolean insert:false], [any data]) : *constructor*\r\n__type:__ *string*. The type of collider this is. Valid values: `polygon`, `box`, `point`, `circle`.  \r\n__satCollider:__ *SAT.Polygon or SAT.Circle*. The SAT Collider to use for collision checks.  \r\n__insert:__ *boolean|optional*. Whether to [Crash.insert()] this Collider.  \r\n__data:__ *any|optional*. Some data to store in [Collider.data].  \r\n__*return:*__ *Collider*. The new Collider.\r\n\r\nThis is the main Collider constructor, which provides some housekeeping methods, like `moveBy`, `update`, etc. All the other constructors ([Crash.Polygon], [Crash.Box], [Crash.Point] and [Crash.Circle]) inherit from this class. They pass their type and a custom SAT Collider to [Crash.Collider], and pass through `insert` and `data`. This way, they inherit the housekeeping functions from Collider's prototype and they can add their own on their own prototype.\r\n\r\n\r\n### Collider.type : *string*\r\nThe type of collider this is. Valid values: `polygon`, `box`, `point`, `circle`.  \r\nThis attribute is used by [Crash.updateAABB()] to determine how to update the [Collider.aabb] attribute.\r\n\r\n\r\n### Collider.sat : *SAT.Polygon|SAT.Circle*\r\nThe actual SAT collider used to do the collision checking. For [Crash.Polygon]s, [Crash.Box]es and [Crash.Point]s, this is a SAT.Polygon, for [Crash.Circle]s, this is a SAT.Circle.  \r\nFor further documentation, I refer to the [SAT.js docs][sat-docs].\r\n\r\n\r\n### Collider.data : *any*\r\nSome data that has to be carried around with the [Crash.Collider]. It can be of any type, and doesn't mean anything to Crash; it's just for your convenience.\r\n\r\n\r\n### Collider.pos : *Vector*\r\nThis is the same [Crash.Vector] as [Collider.sat]`.pos` (so `collider.pos === collider.sat.pos` is `true`).  \r\nThis position is not garanteed to be 'safe', i.e. the [Crash.Collider] may still be colliding with something. [Collider.pos] is the [Crash.Vector] that is moved by [Collider.moveTo()] and [Collider.moveBy()], and is therefore always the most up-to-date, but not always collision checked.\r\n\r\n\r\n### Collider.lastPos : *Vector*\r\nThis is a [Crash.Vector] keeping track of the last position as it was at the end of the [Crash.testAll()] loop. So, during a [Crash.check()] loop, the [Collider.lastPos] attribute as it is inside the [Listener]s, is a copy of [Collider.pos] at the end of the previous iteration.\r\n\r\n\r\n### Collider.lastCheckedPos : *Vector*\r\nThis is a [Crash.Vector] keeping track of the last fully collision checked position of the [Crash.Collider], i.e. a copy of [Collider.pos] at the end of the [Crash.check()] loop.\r\n\r\n\r\n### Collider.aabb : *object*\r\nAn Object with `x1`, `y1`, `x2` and `y2` attributes, that keeps track of the [Crash.Collider]'s axis-aligned bounding box (AABB). It is used to perform [Crash.search()]es.  \r\nWhen you move a [Crash.Collider], don't forget to update this attribute, with [Crash.updateAABB()]. Note that the built-in move methods (`moveBy`, `rotate`, etc.) already do this for you.\r\n\r\n\r\n### Collider.insert () - .\r\n__*return:*__ *Collider*. For chaining.\r\n\r\nShortcut for [Crash.insert()].\r\n\r\n\r\n### Collider.remove () - .\r\n__*return:*__ *Collider*. For chaining.\r\n\r\nShortcut for [Crash.remove()].\r\n\r\n\r\n### Collider.update () - .\r\n__*return:*__ *Collider*. For chaining.\r\n\r\nShortcut for [Crash.update()].\r\n\r\n\r\n### Collider.updateAABB () - .\r\n__*return:*__ *Collider*. For chaining.\r\n\r\nShortcut for [Crash.updateAABB()].\r\n\r\n\r\n### Collider.moved () - .\r\n__*return:*__ *Collider*. For chaining.\r\n\r\nShortcut for [Crash.moved()].\r\n\r\n\r\n### Collider.search () - *Collider[]*\r\n__*return:*__ *Array.\\<Collider\\>*. An array of [Crash.Collider]s that may be colliding with `this`.\r\n\r\nShortcut for [Crash.search()].\r\n\r\n\r\n### Collider.setData (any data) - .\r\n__data:__ *any*. The data to set as the new [Collider.data].  \r\n__*return:*__ *Collider*. For chaining.\r\n\r\nSets the `data` attribute ([Collider.data]) to any value that's passed as the first argument. See [Collider.data] for more info.\r\n\r\n\r\n### Collider.getData () - *any*\r\n__*return:*__ *any*. The value of the `data` attribute ([Collider.data]).\r\n\r\nReturns the value of the `data` attribute ([Collider.data]). See [Collider.data] for more info.\r\n\r\n\r\n### Collider.moveTo (number x, number y) - .\r\n__x:__ *number*. The x-coordinate to move to.  \r\n__y:__ *number*. The y-coordinate to move to.  \r\n__*return:*__ *Collider*. For chaining.\r\n\r\nThis moves the [Crash.Collider]'s `pos` ([Collider.pos]) and `sat.pos` attributes __to__ (`x`, `y`). This calls [Collider.moved()] for you.\r\n\r\n\r\n### Collider.moveBy (number x, number y) - .\r\n*Alias:* [Collider.move()]  \r\n__x:__ *number*. The distance in x direction to move by.  \r\n__y:__ *number*. The distance in y direction to move by.  \r\n__*return:*__ *Collider*. For chaining.\r\n\r\nThis moves the [Crash.Collider]'s `pos` ([Collider.pos]) and `sat.pos` attributes __by__ (`x`, `y`). This calls [Collider.moved()] for you.\r\n\r\n\r\n### Collider.move (number x, number y) - .\r\n*Alias:* [Collider.moveBy()]  \r\n__x:__ *number*. The distance in x direction to move by.  \r\n__y:__ *number*. The distance in y direction to move by.  \r\n__*return:*__ *Collider*. For chaining.\r\n\r\nAlias of [Collider.moveBy()].\r\n\r\n\r\n### Crash.Polygon (Vector pos, Vector[] points, [boolean insert:false], [any data]) ~ [Crash.Collider]\r\n*Inherits from:* [Crash.Collider]  \r\n__pos:__ *Vector*. The base position of the Polygon.  \r\n__points:__ *Array.\\<Vector\\>*. The points/corners of the Polygon.  \r\n__insert:__ *boolean|optional*. Whether to insert the Polygon.  \r\n__data:__ *any|optional*. Any data to set as [Collider.data].  \r\n__*return:*__ *Polygon*.\r\n\r\nA Polygon is a [Crash.Collider] with a base position ([Collider.pos]) and a few points/corners. The points are defined by an array of [Crash.Vector]s, relative to the base position ([Collider.pos]), in counter-clockwise order.  \r\nFor the `insert` and `data` arguments, see [Crash.Collider].\r\n\r\n\r\n### Polygon.setPoints (Vector[] points) - .\r\n__points:__ *Array.\\<Vector\\>*. The points/corners of the Polygon.  \r\n__*return:*__ *Polygon*. For chaining.\r\n\r\nA shortcut for [Collider.sat]`.setPoints()`, which calls [Collider.moved()] for you.\r\n \r\n \r\n### Polygon.setAngle (number angle) - .\r\n__angle:__ *number*. The angle by which to rotate the Polygon (in radians).  \r\n__*return:*__ *Polygon*. For chaining.\r\n\r\nA shortcut for [Collider.sat]`.setAngle()`, which calls [Collider.moved()] for you.\r\n \r\n \r\n### Polygon.setOffset (number offset) - .\r\n__offset:__ *number*. The offset by which to translate the points of the Polygon.  \r\n__*return:*__ *Polygon*. For chaining.\r\n\r\nA shortcut for [Collider.sat]`.setOffset()`, which calls [Collider.moved()] for you.\r\n \r\n \r\n### Polygon.rotate (number angle) - .\r\n__angle:__ *number*. The angle by which to rotate the points of the Polygon.  \r\n__*return:*__ *Polygon*. For chaining.\r\n\r\nA shortcut for [Collider.sat]`.rotate()`, which calls [Collider.moved()] for you.\r\n \r\n \r\n### Crash.Circle (Vector center, number radius, [boolean insert:false], [any data]) ~ [Crash.Collider]\r\n__center:__ *Vector*. The position of the center of the Circle.  \r\n__radius:__ *number*. The radius of the Circle.  \r\n__insert:__ *boolean|optional*. Whether to insert the Circle.  \r\n__data:__ *any|optional*. Any data to set as [Collider.data].\r\n__*return:*__ *Circle*\r\n\r\nA Circle is a [Crash.Collider], with a center and radius.  \r\nFor the `insert` and `data` arguments, see [Crash.Collider].\r\n\r\n\r\n### Crash.Point (Vector position, [boolean insert:false], [any data]) ~ [Crash.Collider]\r\n__position:__ *Vector*. The position of the Point.  \r\n__insert:__ *boolean|optional*. Whether to insert the Point.  \r\n__data:__ *any|optional*. Any data to set as [Collider.data].\r\n__*return:*__ *Point*\r\n\r\nA Point is a [Crash.Collider] with just a position. It doesn't have a size.  \r\nFor the `insert` and `data` arguments, see [Crash.Collider].\r\n\r\n\r\n### Crash.Box (Vector position, number width, number height, [boolean insert:false], [any data]) ~ [Crash.Collider]\r\n__position:__ *Vector*. The position of the Box.  \r\n__width:__ *number*. The width of the Box.  \r\n__height:__ *number*. The height of the Box.  \r\n__insert:__ *boolean|optional*. Whether to insert the Box.  \r\n__data:__ *any|optional*. Any data to set as [Collider.data].\r\n__*return:*__ *Box*\r\n\r\nA Box is a [Crash.Collider] in a rectangular shape with a position (the bottom-left corner), a width and a height.  \r\nFor the `insert` and `data` arguments, see [Crash.Collider].\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n### Listener (Collider a, Collider b, Response res, function cancel) : *function*\r\n__a:__ *Collider*. The [Crash.Collider] that collides with `b`.  \r\n__b:__ *Collider*. The [Crash.Collider] that collides with `a`.  \r\n__res:__ *Response*. The [Crash.Response] for this collision.  \r\n__cancel:__ *function*. Cancels the current check loop. See [Crash.testAll()] for more info.\r\n\r\nA listener is a function that is called every time a collision is detected by [Crash.testAll()], [Crash.check()] or [Crash.checkAll()] and will be passed four arguments: the two [Crash.Collider]s that are colliding, the [Crash.Response] for this collision and [Crash.cancel()], which cancels the current check loop. See [Crash.testAll()] for more info about this.  \r\nThe context of the listener (`this`) will be set to `Crash`.  \r\nYou can add a listener with [Crash.onCollision()] and you can remove them with [Crash.offCollision()]. All listeners are stored in [Crash.__listeners], which is intended for private use.\r\n\r\n\r\n\r\n\r\n\r\n## License\r\n\r\nThe MIT License (MIT)\r\n\r\nCopyright (c) 2014-2015 Tuur Dutoit\r\n\r\nPermission is hereby granted, free of charge, to any person obtaining a copy\r\nof this software and associated documentation files (the \"Software\"), to deal\r\nin the Software without restriction, including without limitation the rights\r\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\ncopies of the Software, and to permit persons to whom the Software is\r\nfurnished to do so, subject to the following conditions:\r\n\r\nThe above copyright notice and this permission notice shall be included in\r\nall copies or substantial portions of the Software.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\nTHE SOFTWARE.\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n[crash.js]: https://raw.githubusercontent.com/TuurDutoit/crash/master/crash.js\r\n[crash.min.js]: https://raw.githubusercontent.com/TuurDutoit/crash/master/crash.min.js\r\n[RBush]: https://github.com/mourner/rbush\r\n[rbush-docs]: https://github.com/mourner/rbush/blob/master/README.md\r\n[SAT.js]: https://github.com/jriecken/sat-js\r\n[sat-docs]: https://github.com/jriecken/sat-js/blob/master/README.md\r\n[require.js]: http://requirejs.org\r\n[source code]: https://github.com/TuurDutoit/crash/blob/master/crash.js\r\n[issue tracker]: https://github.com/TuurDutoit/crash/issues\r\n[getting-started]: #getting-started\r\n[API]: #api\r\n\r\n\r\n[Crash]: #crash-1\r\n[Crash.RBush]: #crashrbush--function\r\n[Crash.SAT]: #crashsat--object\r\n[Crash.Vector]: #crashvector--constructor\r\n[Crash.V]: #crashv--constructor\r\n[Crash.Response]: #crashresponse--constructor\r\n[Crash.rbush]: #crashrbush--rbush\r\n[Crash.RESPONSE]: #crashresponse--response\r\n[Crash.BREAK]: #crashbreak--boolean\r\n[Crash.MAX_CHECKS]: #crashmax_checks--number\r\n[Crash.OVERLAP_LIMIT]: #crashoverlap_limit--number\r\n[Crash.__listeners]: #crash__listeners--array\r\n[Crash.__notYetInserted]: #crash__notyetinserted--array\r\n[Crash.__moved]: #crash__moved--array\r\n[Crash.init()]: #crashinit-number-maxentries9---\r\n[Crash.insert()]: #crashinsert-collider-collider---\r\n[Crash.remove()]: #crashremove-collider-collider---\r\n[Crash.all()]: #crashall----collider\r\n[Crash.search()]: #crashsearch-collider-collider---collider\r\n[Crash.clear()]: #crashclear---\r\n[Crash.addToMoved()]: #crashaddtomoved-collider-collider---\r\n[Crash.update()]: #crashupdate-collider-collider---\r\n[Crash.moved()]: #crashmoved-collider-collider---\r\n[Crash.reset()]: #crashreset-number-maxentries---\r\n[Crash.cancel()]: #crashcancel----false\r\n[Crash.getTestString()]: #crashgetteststring-string-type1-string-type2---string\r\n[Crash.onCollision()]: #crashoncollision-function-listener---\r\n[Crash.offCollision()]: #crashoffcollision-function-listener---\r\n[Crash.__onCollision()]: #crash__oncollision-collider-a-collider-b-response-res---\r\n[Crash.extend()]: #crashextend-function-child-function-base---undefined\r\n[Crash.updateAABB()]: #crashupdateaabb-collider-collider---\r\n[Crash.updateAABBPolygon()]: #crashupdateaabbpolygon-polygon-collider---\r\n[Crash.updateAABBBox()]: #crashupdateaabbbox-box-collider---\r\n[Crash.updateAABBCircle()]: #crashupdateaabbcircle-circle-collider---\r\n[Crash.updateAABBPoint()]: #crashupdateaabbpoint-point-collider---\r\n[Crash.test()]: #crashtest-collider-a-collider-b-response-res---boolean\r\n[Crash.testAll()]: #crashtestall-collider-collider-response-res---boolean\r\n[Crash.check()]: #crashcheck----\r\n[Crash.checkAll()]: #crashcheckall----\r\n[Crash.Collider]: #crashcollider-string-type-satpolygonsatcircle-satcollider-boolean-insertfalse-any-data--constructor\r\n[Collider.type]: #collidertype--string\r\n[Collider.sat]: #collidersat--satpolygonsatcircle\r\n[Collider.data]: #colliderdata--any\r\n[Collider.pos]: #colliderpos--vector\r\n[Collider.lastPos]: #colliderlastpos--vector\r\n[Collider.lastCheckedPos]: #colliderlastcheckedpos--vector\r\n[Collider.aabb]: #collideraabb--object\r\n[Collider.insert()]: #colliderinsert----\r\n[Collider.remove()]: #colliderremove----\r\n[Collider.update()]: #colliderupdate----\r\n[Collider.updateAABB()]: #colliderupdateaabb----\r\n[Collider.moved()]: #collidermoved----\r\n[Collider.search()]: #collidersearch----collider\r\n[Collider.setData()]: #collidersetdata-any-data---\r\n[Collider.getData()]: #collidergetdata----any\r\n[Collider.moveTo()]: #collidermoveto-number-x-number-y---\r\n[Collider.moveBy()]: #collidermoveby-number-x-number-y---\r\n[Collider.move()]: #collidermove-number-x-number-y---\r\n[Crash.Polygon]: #crashpolygon-vector-pos-vector-points-boolean-insertfalse-any-data--crashcollider\r\n[Polygon.setPoints()]: #polygonsetpoints-vector-points---\r\n[Polygon.setAngle()]: #polygonsetangle-number-angle---\r\n[Polygon.setOffset()]: #polygonsetoffset-number-offset---\r\n[Polygon.rotate()]: #polygonrotate-number-angle---\r\n[Crash.Circle]: #crashcircle-vector-center-number-radius-boolean-insertfalse-any-data--crashcollider\r\n[Crash.Point]: #crashpoint-vector-position-boolean-insertfalse-any-data--crashcollider\r\n[Crash.Box]: #crashbox-vector-position-number-width-number-height-boolean-insertfalse-any-data--crashcollider\r\n[Listener]: #listener-collider-a-collider-b-response-res-function-cancel--function\r\n","google":"UA-62013657-1","note":"Don't delete this file! It's used internally to help with page regeneration."}